# ======= Этап 1: Сборка приложения =======

# Используем официальный образ Go с конкретной версией для стабильности сборки
FROM golang:1.23.1 AS builder

# Устанавливаем рабочую директорию внутри контейнера
WORKDIR /app

# Копируем файлы go.mod и go.sum отдельно для кеширования зависимостей
COPY go.mod go.sum ./

# Загружаем зависимости заранее
RUN go mod download

# Копируем весь исходный код приложения
COPY . .

# ⚠️ ВАЖНО: Собираем статически слинкованный бинарник для Alpine
RUN CGO_ENABLED=0 GOOS=linux GOARCH=amd64 go build -o server .

# ======= Этап 2: Минимальный образ для запуска приложения =======

# Используем минимальный стабильный образ Alpine Linux для финального контейнера
FROM alpine:3.21.3

# Устанавливаем рабочую директорию внутри контейнера
WORKDIR /app

# Создаём непривилегированного пользователя и группу с фиксированными UID/GID
RUN addgroup -S appgroup && adduser -S appuser -G appgroup

# Копируем готовый бинарник из стадии сборки
COPY --from=builder /app/server .

# Меняем владельца файлов на созданного пользователя
RUN chown -R appuser:appgroup /app

# Переключаемся на непривилегированного пользователя
USER appuser

# EXPOSE — это лишь **мета-информация** для документации образа.
# Она сообщает, что приложение внутри контейнера слушает на порту 8080.
# ⚠️ Важно: EXPOSE сам по себе не открывает порт для внешнего мира!
# Чтобы порт стал доступен снаружи, при запуске контейнера нужно явно указать флаг -p:
# docker run -p 8080:8080 my-go-server
EXPOSE 8080

# Устанавливаем команду по умолчанию для запуска контейнера
CMD ["./server"]
